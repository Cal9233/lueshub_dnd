<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Character Data Debug</title>
    <style>
        body {
            font-family: monospace;
            padding: 20px;
            max-width: 800px;
            margin: 0 auto;
            background: #f5f5f5;
            color: #333;
        }
        h1, h2 {
            color: #7b2cbf;
        }
        pre {
            background: #fff;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #ddd;
            overflow-x: auto;
        }
        .success {
            color: green;
            font-weight: bold;
        }
        .error {
            color: red;
            font-weight: bold;
        }
        button {
            background: #7b2cbf;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px 0;
        }
        button:hover {
            background: #5a189a;
        }
        input {
            padding: 8px;
            width: 100px;
            margin-right: 10px;
        }
    </style>
</head>
<body>
    <h1>Character Data Debug</h1>
    
    <div>
        <label for="charId">Character ID:</label>
        <input type="number" id="charId" value="5">
        <button id="loadBtn">Load Character Data</button>
    </div>
    
    <h2>Raw Character Data:</h2>
    <pre id="rawData">Load a character to see data...</pre>
    
    <h2>Parsed Notes:</h2>
    <pre id="parsedNotes">Load a character to see parsed notes...</pre>
    
    <h2>Parsed Spell Slots:</h2>
    <pre id="parsedSpellSlots">Load a character to see parsed spell slots...</pre>
    
    <h2>Test JSON Parse:</h2>
    <pre id="jsonParseTest">Load a character to test JSON parsing...</pre>
    
    <script>
        document.getElementById('loadBtn').addEventListener('click', async function() {
            const charId = document.getElementById('charId').value;
            const rawDataElement = document.getElementById('rawData');
            const parsedNotesElement = document.getElementById('parsedNotes');
            const parsedSpellSlotsElement = document.getElementById('parsedSpellSlots');
            const jsonParseTestElement = document.getElementById('jsonParseTest');
            
            try {
                // Direct fetch from the database
                const response = await fetch(`api/raw_character.php?id=${charId}`);
                const data = await response.json();
                
                if (data.success && data.character) {
                    // Display raw data
                    rawDataElement.textContent = JSON.stringify(data.character, null, 2);
                    
                    // Test notes parsing
                    let notesResult = "";
                    try {
                        const notes = data.character.notes;
                        notesResult += `Notes type: ${typeof notes}\n`;
                        notesResult += `Notes raw value: ${notes}\n\n`;
                        
                        let parsedNotes;
                        try {
                            parsedNotes = JSON.parse(notes);
                            notesResult += `<span class="success">✓ JSON.parse successful</span>\n`;
                            notesResult += `Parsed notes: ${JSON.stringify(parsedNotes, null, 2)}`;
                        } catch (e) {
                            notesResult += `<span class="error">✗ JSON.parse failed: ${e.message}</span>\n`;
                            
                            // Try to clean the string and parse again
                            notesResult += `\nAttempting to clean and parse...\n`;
                            
                            // Replace literal newlines with \\n
                            const cleanedNotes = notes
                                .replace(/\n/g, '\\n')
                                .replace(/\r/g, '\\r')
                                .replace(/\\"/g, '\\\\"')
                                .replace(/^"(.*)"$/, '$1'); // Remove outer quotes if present
                            
                            notesResult += `Cleaned notes: ${cleanedNotes}\n\n`;
                            
                            try {
                                parsedNotes = JSON.parse(cleanedNotes);
                                notesResult += `<span class="success">✓ Cleaned JSON.parse successful</span>\n`;
                                notesResult += `Parsed cleaned notes: ${JSON.stringify(parsedNotes, null, 2)}`;
                            } catch (e) {
                                notesResult += `<span class="error">✗ Cleaned JSON.parse failed: ${e.message}</span>`;
                            }
                        }
                    } catch (e) {
                        notesResult = `<span class="error">Error accessing notes property: ${e.message}</span>`;
                    }
                    parsedNotesElement.innerHTML = notesResult;
                    
                    // Test spell slots parsing
                    let spellSlotsResult = "";
                    try {
                        const spellSlots = data.character.spell_slots_json;
                        spellSlotsResult += `Spell slots type: ${typeof spellSlots}\n`;
                        spellSlotsResult += `Spell slots raw value: ${spellSlots}\n\n`;
                        
                        let parsedSpellSlots;
                        try {
                            parsedSpellSlots = JSON.parse(spellSlots);
                            spellSlotsResult += `<span class="success">✓ JSON.parse successful</span>\n`;
                            spellSlotsResult += `Parsed spell slots: ${JSON.stringify(parsedSpellSlots, null, 2)}`;
                        } catch (e) {
                            spellSlotsResult += `<span class="error">✗ JSON.parse failed: ${e.message}</span>\n`;
                            
                            // Try to clean the string and parse again
                            spellSlotsResult += `\nAttempting to clean and parse...\n`;
                            
                            // Replace literal newlines with \\n
                            const cleanedSpellSlots = spellSlots
                                .replace(/\n/g, '\\n')
                                .replace(/\r/g, '\\r')
                                .replace(/\\"/g, '\\\\"')
                                .replace(/^"(.*)"$/, '$1'); // Remove outer quotes if present
                            
                            spellSlotsResult += `Cleaned spell slots: ${cleanedSpellSlots}\n\n`;
                            
                            try {
                                parsedSpellSlots = JSON.parse(cleanedSpellSlots);
                                spellSlotsResult += `<span class="success">✓ Cleaned JSON.parse successful</span>\n`;
                                spellSlotsResult += `Parsed cleaned spell slots: ${JSON.stringify(parsedSpellSlots, null, 2)}`;
                            } catch (e) {
                                spellSlotsResult += `<span class="error">✗ Cleaned JSON.parse failed: ${e.message}</span>`;
                            }
                        }
                    } catch (e) {
                        spellSlotsResult = `<span class="error">Error accessing spell_slots_json property: ${e.message}</span>`;
                    }
                    parsedSpellSlotsElement.innerHTML = spellSlotsResult;
                    
                    // Test direct JSON parsing
                    let jsonTestResult = "";
                    try {
                        // Test creating a clean character object for client use
                        const cleanCharacter = { ...data.character };
                        
                        // Handle notes
                        if (typeof cleanCharacter.notes === 'string') {
                            try {
                                cleanCharacter.notes = JSON.parse(cleanCharacter.notes);
                            } catch (e) {
                                // Set empty array if parsing fails
                                cleanCharacter.notes = [];
                                jsonTestResult += `<span class="error">Failed to parse notes: ${e.message}</span>\n`;
                            }
                        }
                        
                        // Handle spell slots
                        if (typeof cleanCharacter.spell_slots_json === 'string') {
                            try {
                                cleanCharacter.spell_slots_json = JSON.parse(cleanCharacter.spell_slots_json);
                            } catch (e) {
                                // Set empty object if parsing fails
                                cleanCharacter.spell_slots_json = {};
                                jsonTestResult += `<span class="error">Failed to parse spell_slots_json: ${e.message}</span>\n`;
                            }
                        }
                        
                        jsonTestResult += `<span class="success">Successfully created clean character object</span>\n`;
                        jsonTestResult += `Clean character: ${JSON.stringify(cleanCharacter, null, 2)}`;
                    } catch (e) {
                        jsonTestResult = `<span class="error">Error creating clean character: ${e.message}</span>`;
                    }
                    jsonParseTestElement.innerHTML = jsonTestResult;
                } else {
                    rawDataElement.textContent = `Error: ${data.message || 'Could not load character data'}`;
                    parsedNotesElement.textContent = 'No data available';
                    parsedSpellSlotsElement.textContent = 'No data available';
                    jsonParseTestElement.textContent = 'No data available';
                }
            } catch (error) {
                rawDataElement.textContent = `Error: ${error.message}`;
                parsedNotesElement.textContent = 'Error occurred';
                parsedSpellSlotsElement.textContent = 'Error occurred';
                jsonParseTestElement.textContent = 'Error occurred';
            }
        });
    </script>
</body>
</html>